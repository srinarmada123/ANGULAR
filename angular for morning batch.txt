Angular
----------
Angular is a client side framework, which is used to create Web Applications. [SPA's]

SPA	-	Single Page Application - Asychronous - AJAX

framework provides skeleton of the project and specifies clear guidelines, where to write which type of code.

AngularJS	->	1.x series	->	JavaScript Based

Angular		->	2 to 12	->	TypeScript Based

Angular can be used in combination with any server side platform such as JAVA,Nodejs, ASP.NET, PHP, Python etc.


NPM ->	Node Package Manager

TypeScript -> 	OOP

Angular is developed using "TypeScript" language,  which is a superset of javascript language.

Angular is developed by Google.

Typescript is developed by Microsoft.

Angular is free-to-use. (commercially too)

Angular is Open Source. That means the source code of angular is available online for free of cost.

Angular is cross-platform. That means it works in all the browsers, except less than ie9.

Angular is mainly used to create "data bindings".  We establish relation between a property and html element. When the value of property is changed, the same will be automatically effected in the corresponding html element, and vice versa. So that the developer need not write  any code for DOM manipulation. Thus the developer can fully concentrate on the application logic, instead of write huge code for DOM manipulations. So we can achieve clean separation between application logic and "DOM manipulations".

Angular mainly works based on Components. The component is a class, which represents a specific section of the page.

int x;

x=10;

<property>="value";

  title = 'myfirstproject';

  {{title}}	->	Interpollation.

App	->	Component

app.component.html
app.component.ts
app.component.spec.ts
app.component.css


Web page	-	Header
		sidebar
		main area
		footer

Angular mainly works on components. 
Component is a class, which represents a specific part of the web page.

Goals of Angular
---------------------
Separation of DOM Manipulation [html] from application logic [ts].

Make a SPA [Single Page Application] development easier. SPA provides client-side navigation system. But can communicate with server only through AJAX; there web page never gets refreshed fully. Ex: Gmail

Separation of Business logic [service.ts] from Application logic [ts]. 

Enable Unit Testing. The components can be unit tested individually.

Versions
-----------
AngularJs			->	1.x series

Angular 2 is not extension to AngularJs. It is a completely rebuilt, rewrite. Angular 2 is rewrite from the same team that built angularjs.

Angular 2+ all are mostly similar, except some internal changes for stability and performance.

AngularJs						Angular
1. AngularJS has performance drawbacks because, the 	1. Angular is faster in performance because it
digest loop checks and updates all properties when a field 	updates a single property that has been really
or property has been modified.				modified.

The digest loop may repeat up to 10 times. due to a watcher 	No digest loop and no need of any repetition.
of one property can update other property.

2. AngularJs is based on JavaScript, which is prototype	2. Angular is based on TypeScript, which is
based oops language.				class based oops language.

3. AngularJs is based on MVC architecture. The code 	3. Angular is based on "Components". 
will be divided into 3 major parts called model, view,	Component is a class that stores data and 
controller. Model is an object that stores data. View is 	manipulate the data. View is a html file that
a html file contains presentation logic to display data.	contains presentation logic to display data.
Controller is a function that manipulates data.

4. AngularJS is mainly used for development of 		4. Angular is  also mainly used for 
SPA's [Single Page Application].			development of SPAs.

5. Apart from data bindings, Angularjs provides		5. Apart from data bindings, Angular
many additional features such as validations, routing, 	provides many additional features such as
animations, services, filters, providers, factories,		validations, routing, animations, services, 
 configuration, AJAX  etc.				pipes, AJAX etc.

6. Supports "Scopes" (Models) to store data.		6. Instead of Scopes alternately Components.

7. Supports Only one  expression syntax. {{ }}		7. Supports Multiple expression syntaxes 
						{{}}, [], (), [()]

8. Doesn't provide any CLI (command Line		8. Provides CLI, to generate components and
Interface), to generate components and services easily 	services easily from the command prompt 
from the command prompt commands. 			easily.

Features of Angular:
-------------------------
1. Typescript Based: Predefined and user-defined code is developed based on TypeScript Language.
2. Faster Performance: Angular 2+ executes faster than AngularJS.
3. Modular: Angular is divided into multiple small parts called packages. For example "core",""platform-browser" etc. The developer can use any of these modules based on the requirement.

Building Blocks of Angular:-
---------------------------------
1. Component: 	Application State + Application Logic
2. Metadata:	Details about the component / module etc.
3. Template: 	Design logic (HTML)
4. Data Binding:	Connection between HTML element and Component Property.
5. Module:	Group of components, directives, pipes.
6. Service:	Re-usable code / business Logic.
7. Dependency Injection:	Injecting (loading) Service objects into components.
8. Directive:		Manipulation DOM Elements.
9. Pipe:			Transforming values before displaying.

Types of compilation in Angular:-
----------------------------------------
2 types

1. Just-in time compilation
	Templates (.html files) and angular compiler files will be loaded into the browser and then the templates will be compiled automatically at the time of execution, when the component is invoked. 

	The template will be compiled only for the first time, when it invoked, after loading the application files into the browser.

Disadvantages:- Performance is slower, because every time when you run the application, the templates will be loaded into browser and compiled in the browser. it takes some time to compile.

Advantage: The developer need not compile it manually at command prompt, for each modification of file.

This is recommended during the development.

Bootstraping (loading app module into the browser) is done by @angular/platform-browser-dynamic" package.
	
2. Ahead-of-time compilation
	 The developer gives "ngc" command in the command prompt, then the "ngc" compiler compiles the templates into javascript code, the compiled javascript code will be loaded into the browser and it directly executes. There is no need of loading "templates (.html files)" and "angular compiler scripts into the browser.

Advantage: Performance is faster, because the templates are already compiled.

Disadvantage: The developer need to compile it manually at command prompt, for each modification of code.

This is recommended in the production server only.

Bootstraping is done by "@angular/platform-browser" package.

Installation
--------------
nodejs

C:\Users\sai-ram>node -v
v14.15.5

create one folder

npm install -g @angular/cli

visual studio code 

Steps to prepare first application
-----------------------------------------
1. ng new Projectname
	feedback 	no
	routing	no 
	css	

2. start->search->cmd 
	open projectname
	code .	->	it opens visual studio.


3. Running
	npm start (or) ng serve (or) ng s (or) 

	ng s 0  (or) ng serve -open   it directly opens browser.
	
Folder Structure
--------------------
package.json:-
------------------
	The "package.json file represents the configuration settings / meta data of the application.
	It specifies the packagename, version, dependencies etc.
	It is a fixed filename.
	It is must, without which the application is not accepted.
	It is a JSON files, which means it contains key/value pairs. Every key and value must be within 	double quotes " " / Single quotes ''.
	
Properties of "package.json":
	1. name: 	Represents name of the application.
		It can be maximum of 214 characters.
		Non-URL friendly characters such as /,;,@ etc. are not allowed.
		Ex: "name":"app1"

	2. version:	 Represents version of the application. Ex: 1.0.0
		It should have 3 numbers major version, minor version, subminor version.
		EX: "version" : "0.0.0"

	3. license: Represents license of the application. Ex: MIT,ISC
		MIT - Massachusetts Institute of Technology.
		MIT license allows to create private applications that can be used either prviately 		within the organization and also can be shared with other known organizations.
		Ex: "license" : "MIT"

		ISC  - Internet Systems Consortium.
		ISC license allows to create public applications that can be used anywhere.
		Ex: "license" :"ISC"

	4. scripts:	Represents a set of commands that can run on command prompt to run, test the 		applications using commands.
		Ex: "scripts":
			{
			"start":"ng serve"
			}
	5. private: Represents whether the application should be used privately within the same 		organization or not.
		If it is true, it can be used only within the same organization. Outside usage is not 		permitted.
		Ex: "private":true
	6. dependencies: Represents the list of packages that are to be installed to run the 				 applications. These packages will be installed in both developer machine and 		production server.	
		Ex: "dependencies":
			{
				"@angular/core":"~11.2.1"
			}
	7. devDependencies: Represents the list of packages that are to be installed ti develop the 					application. These packages will be installed only in the developer machine. 				not in the production server.
			Ex: "devDependencies":
				{
					"@angular/cli":"~11.2.1"
				}				

Packages of Angular
--------------------------
	The angular framework is available as a collection of packages.
	Each feature of the framework is representsed as a package. For ex: routing is available as a 	package called "@angular/router".
	We have to install those packages in order to develop angular application.
	2 types
	1. Angular Packages
		These packages are part of angular framework.
		Ex: @angular/core,@angular/platform-browser etc.

	2. Non-Angular Packages
		These packages are not part of angular framework. provided by third party companies, 		but needed / useful in angular applications.
		EX: "typescript"
			This package provides typescript compiler, which is used to compile 			"typescript files (.ts)" into javascript files(.js).
			
			This is the mandatory package.
			This package must be installed globally, with -g option.
		rxjs:
		-----
			This package "rxjs" (Reactive Extensions for JavaScript) provides necessary 			code for making ajax calls to the server.

			This is the mandatory package.
		

		jasmine:
		----------
			This package is used to wrtie test cases for unit testing of components. It is 			used to execute test cases within one browser.
			This is mandatory package.

		karma:
		--------
			This package is used to execute test cases on different browsers.
			This is mandatory package.
			
tsconfig.json
----------------
	Every compiler has some configuration settings.
	This file is used to set configuration settings of the "tsc" (typescript compiler).
	The" tsc" compiler automatically reads the "tsconfig.json" file; and then it compiles the ".ts" files 	into ".js" files.
	This is a fixed filename.

	"tsconfig.json" - Configuration Settings
		sourceMap
		--------------
			true/false
		
			true: Generates "source map" files. The source map file contains mapping 				between line numbers of ".ts" files into ".js" file. Based on the source map 				files, you  can debug the typescript code. It is recommended to generate 
			source map files during development.
		
			false: Source map files will not be generated. So then we can debug 			"javascript code" only. Source map files are not required in production.


		target:
			Represents javascript version, into which the ".ts" file have to be compiled.
			Ex: "es6".
			Recommended: "es6"
			options: es3 | es5 | es6
	experimentalDecorators:
		true|false
		true: It supports decorators.  Ex: @Component, @NgModule, @Injectable etc.
		false: It doesn't support decorators.
	emitDecoratorsMetadata:
		true|false
		true: It supports decorators with metadata.
		false: It doesn't supports decorators with metadata.
	lib:
	It represents the list of library files to be included while compilation of the typescript files.	
	"lib": [
		      "es2018",
		      "dom"
    		]
	Note: These will be installed automatically.

	es2018:
		This library contains essential data type such as Number, String, Boolean, Object, 		Function, RegEx etc.

	dom: This library contains essential classes such as "HTML element", "Document","Window" etc.

	outDir: Specifies the directory ( folder) where the compiled files needs to be stored.

tslint.json
-------------
	This file contains configuration settings for "tslint" tool, which is used to verify whether the 		typescript files are following a set of coding standards or not.
	Ex: We can check the maximum length of the line, indentation etc.

karma.conf.js
-----------------
	This file contains configuration settings for "karma" tool, which is used to execute unit test cases 	on multiple browsers.

angular.json
---------------
	This file contains configuration settings for "@angular/cli" tool, which is used to create, compile 	and run the application.
	It contains settings such as home page (index.html), startup file name (main.ts), css filename 	(styles.css) etc.

polyfills.ts
-------------
	This file contains configuration settings for importing (loading) polyfills which are needed to run angular applications on old browsers such as ie.

src/styles.css
----------------
	This file contains CSS styles that are applicable for entire application.

src/index.html
------------------
	This file is home pge (startup page) for the entire application.
	The content of the entire application appears in the same html file only.
	This file invokes the "AppComponent" using <app-root></app-root> tag.

main.ts
----------
	This is the first typescript file that executes in the angular application.
	It enables the "Production mode" and specifies the startup module.

Application Modes in angular
-------------------------------------
	1. Development Mode:
		Change Detection occurs twice. Raises error if any different detected between first 		attemp and second attempt. This is to identify whether any side effects in change 		detection.
		It is the default mode.
	2. Production Mode
		Change Detection occurs only once.
		syntax: enableProdMode();

Startup Module:-
--------------------
	Angular application can has any no.of modules.
	The "startup module" is a module, which needs to be executed first in the angular application.
	By default startup module name is  "AppModule".
	Loading the startup module is also called as "Bootstrapping the module".
	syntax:- platformBrowserDynamic().bootstrapModule(Modulename);

src/app/app.module.ts
----------------------------
	This file contains definition of "AppModule".
	Angular application can has any no.of modules. It should contains atleast one module, that is 	called as "AppModule".
	This file imports "AppComponent" from "app.component.ts" file and bootstraps the same in 
	"AppModule".

src/app/app.component.ts
---------------------------------
This file contains definition of "AppComponent".
Angular application can has any no.of components. It should contain atleast one component, that is called as "AppComponent".

This file specifies path of template file "app.component.html" and css file "app.component.css" file.

src/app/app.component.html
-------------------------------------
This file contains actual content (html code) of the component.
Every component should have a template.
This template content will be rendered into <app-root></app-root> tag at index.html.

src/app/app.component.css
-----------------------------------
This file contains css styles of "AppComponent".
One component can have only one css file.
By default, this file is empty.

src/app/app.component.spec.ts
----------------------------------------
This file contains test cases for "AppComponent".
This test case file should have "spec.ts" file extension.


e2e:-
-----
end to end testing related files.

node_modules:-
-------------------
packages that are required for angular application.


assets:-
---------
Images can placed inside assets.


Components
----------------
The component class represents certain section of the webpage. Ex: "login form" is represented login component.
The component class includes "properties" (to store data), "methods" (event handler methods to manipulate data).
Every angular application contains atleast one component, which is called as "AppComponent". You can create any no.of components in the project.
The component is invoked (called) through a custom tag (user-defined tag). Ex: LoginComponent is invoked through <login></login> tag. The custom tag is also called as "selector".
The component class should have a decorator called "@Component", to define that the class is a component class. 
syntax:-
---------
import { Component } from '@angular/core';
					-->	Importing section
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})

@Component - decorator

({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
					-->	Metadata
export class AppComponent {
  	property:datatype=value;		-->	typescript variable syntax
	method(arguments): return type	-->	method
}
					-->	class 


Meta Data Properties of Component:
	1. selector: Represents the selector (tag) to invoke the component.
	2. template: Represents the template content of the component.
	3. templateUrl: Represents the html file that has to be rendered when the component is invoked.
	4. styleUrls: Represents the list if style sheets (css files) that have to be loaded for the component.
	5. providers: Represents the list of services to be imported into the component.
	6. animations: Represents the list of animations to be performed in the component.


Data Bindings:-
	The data binding is the relation between "component" and the "template".
	When the value of "component" is changed, the "template" will be changed automatically. when 	the value of "template" is changed, the "component" will be changed automatically.
	Databinding is 4 types:
	1. Interpollation Binding
	2. Property Binding
	3. Event Binding
	4. Two-Way Data Binding

Interpollation Binding:-
----------------------------
syntax: {{property}}
	It displays the value of the property in the template.
	when the value of property is changed, the same value will be automatically updated in the 	template.
		
	template			component
	{{property}}		Property

App.component.ts
------------------------
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  //property:datatype=value;
  empNo:number=100;
  //property=value;
  empName="Rama";
  //property;
  empSalary;
  constructor()
  {
    this.empSalary=12000;
  }
}

App.component.html
---------------------------
EMPLOYEE INFORMATION<br/>
EMPLOYEE NO = {{empNo}}<br/>
EMPLOYEE NAME = {{empName}}<br/>
EMPLOYEE SALARY = {{empSalary}}

app.component.ts
------------------------
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'project1';
  //property=value;
  eno=100;
  ename="Rama";
  sal=12000;
}

app.component.html
---------------------------
{{title}}
<br/>
EMPLOYEE INFORMATION<br/>
EMPLOYEE NO = {{eno}}<br/>
EMPLOYEE NAME = {{ename}}<br/>
EMPLOYEE SALARY = {{sal}}
<br/>

Property Binding:
---------------------
syntax: <tag [attribute]="property">...</tag>

"Property Binding" is used to send data from component to template and assign the same into an attribute of the tag.

When the value of the property is changed, the same value will be automatically updated in the 	template.
	
	template 				component
	[attribute]="property"		Property


app.component.ts
-----------------------
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'project1';
  //property:datatype=value;
  eno:number=100;
  ename:string="Rama";
  sal:number=12000;
}

app.component.html
---------------------------

<!-- {{title}}
<br/>
EMPLOYEE INFORMATION<br/>
EMPLOYEE NO = {{eno}}<br/>
EMPLOYEE NAME = {{ename}}<br/>
EMPLOYEE SALARY = {{sal}}
<br/> -->
<b>EMPLOYEE INFORMATION</b><br/>
<span>EMPLOYEE NO = <span [innerHTML]="eno"></span></span><br/>
<span>EMPLOYEE NAME = <span [innerHTML]="ename"></span></span><br/>
<span>EMPLOYEE SALARY = <span [innerHTML]="sal"></span></span><br/>

Event Binding:-
------------------
Syntax: <tag (event)="method()"></tag>
	It is used to pass event notifications from template to component.		
	
	template				component
	(event)="method()"			Method

home.component.ts
-----------------------
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-home',
  templateUrl: './home.component.html',
  styleUrls: ['./home.component.css']
})
export class HomeComponent implements OnInit {

  msg:string="";
  constructor() { }

  ngOnInit(): void {
  }
  Show()
  {
    this.msg="Sample button";
    //console.log("This is simple click event");
  }

}

home.component.html
-----------------------------
<p>home works!</p>
<input type="submit" value="Register" (click)="Show()"/>
<div [innerHTML]="msg"></div>

app.component.html
---------------------------
<app-home></app-home>

Two Way Data Binding:-
----------------------------
Syntax: <tag [(ngModel)]="property"></tag>

Two Way Data Binding is a combination of both "property binding" and "event binding".

When you change the value of property, the same will be automatically updated in the html element.

When you change the value of html element, the same will be automatically updated in the property.

The ngModel is a predefined-directive, which is used to create two-way data binding.

Two-Way Binding is applicable only for <input> and <select> tags.

"FormsModule" must be imported in order to use two way data binding.

	template				component
[(ngModel)]="property"			property
<input> and <select> only

app.module.ts
------------------
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
					import { FormsModule } from '@angular/forms';

import { AppComponent } from './app.component';
import { RegistrationExComponent } from './registration-ex/registration-ex.component';

@NgModule({
  declarations: [
    AppComponent,
    RegistrationExComponent
  ],
  imports: [
    BrowserModule,
					    FormsModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

home.component.ts
--------------------------
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-home',
  templateUrl: './home.component.html',
  styleUrls: ['./home.component.css']
})
export class HomeComponent implements OnInit {

  username:string="";
  password:string="";
  msg:string="";
  constructor() { }

  ngOnInit(): void {
  }
  signin()
  {
    if(this.username=="sai"&&this.password=="ram")
      this.msg="Login Successful";
      else
      this.msg="Login Failed";
  }

}

home.component.html
<!-- <p>home works!</p>
<input type="submit" value="Register" (click)="Show()"/>
<div [innerHTML]="msg"></div> -->

<h2>Login Form</h2>
<table>
    <tr>
        <td>User Name:</td>
        <td><input type="text" id="un" [(ngModel)]="username"/></td>
    </tr>
    <tr>
        <td>Pass Word:</td>
        <td><input type="password" id="pw" [(ngModel)]="password" /></td>
    </tr>
    <tr>
        <td></td>
        <td><input type="submit" (click)="signin()" /></td>
    </tr>
</table>

<div [innerHTML]="msg"></div>

Built-in Directives
----------------------
Style
------
	It is used to set the CSS property value dynamically at run time.
	When the value of component property is changed, the value of css property will be 	automatically gets changed.
	Syntax:
		<tag [style.cssproperty]="component property">
		</tag>

How to generate component?
-------------------------------------
ng g c builtindirectivesex

builtindirectivesex.component.ts
-----------------------------------------

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-builtindirectivesex',
  templateUrl: './builtindirectivesex.component.html',
  styleUrls: ['./builtindirectivesex.component.css']
})
export class BuiltindirectivesexComponent implements OnInit {
  marks:number=30;
  mycolor:string="";

  constructor() { 
    if(this.marks>=35)
      this.mycolor="green";
    else  
      this.mycolor="red";
  }

  ngOnInit(): void {
  }

}

builtindirectivesex.component.html
---------------------------------------------
<div>
<p>builtindirectivesex works!</p>
<!-- <tag [style.cssproperty]="component property">
</tag> -->
<div [style.color]="mycolor">{{marks}}</div>
</div>

app.component.html
---------------------------
<app-builtindirectivesex></app-builtindirectivesex>


ngClass
----------
It is used to set the css classname dynamically at runtime.
When the value of component property is changed, the css class will be automatically chaged.
Use this directive to set styles with multiple properties, conditionally at runtime.

syntax:-
	<tag [ngClass]="componentproperty">
	</tag>

ng g c ngclassex

ngclassex.component.ts
-------------------------------
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-ngclassex',
  templateUrl: './ngclassex.component.html',
  styleUrls: ['./ngclassex.component.css']
})
export class NgclassexComponent implements OnInit {
  marks:number=30;
  myclass:string="";

  constructor() { 
    if(this.marks>=35)
      this.myclass="class1";
    else  
      this.myclass="class2";
  }

  ngOnInit(): void {
  }

}

ngclassex.component.html
----------------------------------
<div>
    <h4>ngClass Example</h4>
    <div [ngClass]="myclass">
        {{marks}}
    </div>
</div>

app.component.html
---------------------------
<app-ngclassex></app-ngclassex>

ngIf:-
------
The "ngIf" displays the element if the condition is "true". Otherwise the element will be deleted from DOM.
syntax:
	<tag *ngIf="condition">
	</tag>
	The "ngIf" must be prefixed with "*", to mark that it accepts "microsyntax", which is not just an expression, it accepts its own syntax.
	Use "ngIf", if you want to display some content based on the condition. The content appears when the condition is true, it disappears when the condition is false.

ng g c ngifex

ngifex.component.ts
---------------------------
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-ngifex',
  templateUrl: './ngifex.component.html',
  styleUrls: ['./ngifex.component.css']
})
export class NgifexComponent implements OnInit {

  marks:number=20;
  b:boolean;

  constructor() { 
    if(this.marks>=35)
      this.b=true;
    else  
      this.b=false;
  }
  ngOnInit(): void {
  }

}

ngifex.component.html
------------------------------
<p>ngifex works!</p>
<!-- <tag *ngIf="condition">
</tag> -->
<div *ngIf="b" style="background-color:#33ff66">
    Congratullations!
</div>
<div *ngIf="!b" style="background-color:#ff0000">
    Better Luck Next Time!!
</div>

app.component.html
---------------------------
<app-ngifex></app-ngifex>


ngIf:-
------
The *ngIf displays the element if the condition is "true", otherwise the element will be deleted from the DOM.
Syntax: <tag *ngIf="condition">
	</tag>
	The ngIf must be prefixed with "*", to mark that it accepts "micro syntax", which is not just an "expression", it accepts its own syntax.
	Use "ngIf" if you want to display some content based on the cindition. The content appears when the condition is true, it disappears when the condition is false.

ng g c ngIfex

.ts
marks:number=70;
b:boolean;

constructor()
{
if(this.marks>=35)
this.b=true;
else
this.b=false;
}

.html
<h3>ngIf</h3>
<div *ngIf="b" style="background-color:#33ff66">
	Congratuallations
</div>
<div *ngIf="!b" style="background-color:#00ccff">
	Better Luck next time!!
</div>

app.component.html
<app-ngifex></app-ngifex>

ngIf and else:
----------------
The "ngIf and else" displays one element if it is "true"; otherwise it displays another element.
syntax: 
	<tag *ngIf="condition; then template1; else template2">	
	</tag>
	<ng-template #template1>
	....
	</ng-template>
	<ng-template #template2>
	.......
	</ng-template>

	The "ng-template" is a container, inside which you can place any no.of tags.
	Use "ngIf and else, if you want to display one content for the true case, another content for the 	false case.
	
ng g c ngIfelseex

ngclassex.component.ts

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-ngclassex',
  templateUrl: './ngclassex.component.html',
  styleUrls: ['./ngclassex.component.css']
})
export class NgclassexComponent implements OnInit {
  marks:number=30;
  b:boolean;
  constructor() {
    if(this.marks>=35)
    {
        this.b=true;
    }
    else
        this.b=false;
   }

  ngOnInit(): void {
  }

}

ngclassex.component.html
<div *ngIf="b; then template1; else template2">	
</div>
<ng-template #template1>
<h1 style="color:green">Congratualations.</h1>
</ng-template>
<ng-template #template2>
<h1 style="color:red">Better Luck Next Time.</h1>
</ng-template>

app.component.html
<app-ngifelseex></app-ngifelseex>

ngSwitch:-
-------------
The "ngSwitch" checks the value of a variable, whether it matches with any one of the "cases" and displays the element when it matches with anyone.
Use "ngSwitch" if you want to display some content for every possible value in a variable.
Syntax:
<tag [ngSwitch]="property">
	<tag *ngSwitchCase="'value'"></tag>
	<tag *ngSwitchCase="'value'"></tag>
	<tag *ngSwitchCase="'value'"></tag>
	<tag *ngSwitchCase="'value'"></tag>
	....
	<tag *ngSwitchDefault></tag>
</tag>

ng g c ngclassex

ngclassex.component.ts

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-ngclassex',
  templateUrl: './ngclassex.component.html',
  styleUrls: ['./ngclassex.component.css']
})
export class NgclassexComponent implements OnInit {
  num:number=0;
  constructor() {
   }

  ngOnInit(): void {
  }

}

ngclassex.component.html

Enter a Number: <input type="text" [(ngModel)]="num"/><br/>
<div [ngSwitch]="num">
	<div *ngSwitchCase="'1'">One</div>
	<div *ngSwitchCase="'2'">Two</div>
	<div *ngSwitchCase="'3'">Three</div>
	<div *ngSwitchCase="'4'">Four</div>	
    <div *ngSwitchCase="'5'">Five</div>	
    <div *ngSwitchCase="'6'">Six</div>	
    <div *ngSwitchCase="'7'">Seven</div>	
	<div *ngSwitchDefault>This is default.</div>
</div>


app.component.html
<app-ngclassex></app-ngclassex>

ngFor:
It is used to repeat the tag once for each element in the array. It generates (repeats) the given content once for one element of the array. For example, you are reading friends names from an array and displaying the same as bulleted list.
We have to prefix "*" before the ngFor, as it is the microsyntax. The "microsyntax" means, it's not just a value, we can write some complex code in it.
arrayname=[value1,value2,...];
Ex:- Displaying products list in the online shopping website.
Use "ngFor" to display list of records. Ex: List of banks, list of salesman and their sales etc.
syntax:
	<tag *ngFor="let variable of arrayname">
	</tag>

ng g c ngforex

ngforex.component.ts
import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-ngforex',
  templateUrl: './ngforex.component.html',
  styleUrls: ['./ngforex.component.css']
})
export class NgforexComponent implements OnInit {
  friendsnames:any[]=[
    {"name":"Rama"},
    {"name":"Sita"},
    {"name":"Siva"},
    {"name":"Sai"}
  ];
  constructor() { }

  ngOnInit(): void {
  }

}

ngforex.component.html
<p>ngforex works!</p>
<ul>
    <li *ngFor="let p of friendsnames">
        {{p.name}}
    </li>
</ul>

<!-- <tag *ngFor="let variable of arrayname">
</tag> -->

Multiple Components
---------------------------
		APP
INDIA			USA	
New Delhi		New York
Chennai			Washing Ton

Multiple Modules
---------------------

Children of Components:-
--------------------------------
Sharing data from parent component to child component
	We can share the data from parent component to child component using "property binding".
	Assign the value of parent component's property to child components property, using "property 	binding".
	Set @Input() decorator for the child component's property to accept value from parent 	component's property. You can import "input" decorator from "@angular/core" package.
steps:
	import "Input":
		import { Input } from '@angular/core';
	Create data in parent property ay parent component:
		class parentcomponent
		{
			parentproperty:datatype;
			....
		}
	Pass data from parent property to child property:
		<child [childproperty]="parentproperty" ...>
		</child>
	Receives data into child property at child component:
		class childcomponent
		{
			@Input() childproperty:datatype;
			...			
		}

ng g c sharingdata

sharingdata.component.ts

import { Component, OnInit } from '@angular/core';

@Component({
  selector: 'app-sharingdata',
  templateUrl: './sharingdata.component.html',
  styleUrls: ['./sharingdata.component.css']
})
export class SharingdataComponent implements OnInit {
  //parentproperty:datatype;
  eno:number=100;
  constructor() { }

  ngOnInit(): void {
  }

}

<p>sharingdata works!</p>
<app-sharingdatatochild [empno]="eno">
</app-sharingdatatochild>

ng g c sharingdatatochild

sharingdatatochild.component.ts

import { Component, Input, OnInit } from '@angular/core';

@Component({
  selector: 'app-sharingdatatochild',
  templateUrl: './sharingdatatochild.component.html',
  styleUrls: ['./sharingdatatochild.component.css']
})
export class SharingdatatochildComponent implements OnInit {
  //@Input() childproperty:datatype;
  //@Input() childproperty:datatype;
  @Input()
  empno!: number;
  constructor() { }

  ngOnInit(): void {
  }

}

sharingdatatochild.component.html
<p>sharingdatatochild works!</p>
EMP NO = {{empno}}

app.component.html
----------------------------
<app-sharingdata></app-sharingdata>

ViewChild:-
-------------
The "ViewChild" represents an element, which is a child of the view (template) of the component.
ViewChild is used to access an element, that is present in the view (template) of the component.
ViewChild can contain a child element of a specific type(class).
ViewChild is used to access properties / methods of the child.

Steps:
	Import "ViewChild":
	import { ViewChild } from '@angular/core'; 
		
	Create ViewChild Property:
	class parentcomponent
	{
		@ViewChild(classname) propertyname:classname;
		....
	}		

	Access properties / methods of the child element, using ViewChild's property:
	this.propertyname.property
	this.propertyname.method()

ng g c sharingdata

sharingdata.component.ts
import { Component, OnInit, ViewChild } from '@angular/core';
import { SharingdatatochildComponent } from '../sharingdatatochild/sharingdatatochild.component';

@Component({
  selector: 'app-sharingdata',
  templateUrl: './sharingdata.component.html',
  styleUrls: ['./sharingdata.component.css']
})
export class SharingdataComponent implements OnInit {
  @ViewChild(SharingdatatochildComponent)
  emp!: SharingdatatochildComponent;

  constructor() { }

  ngOnInit(): void {

  }
  change_data()
  {
    console.log(this.emp.empname);
    this.emp.empname="Sita";
    console.log(this.emp.empname);
  }
}

sharingdata.component.html
<p>sharingdata works!</p>
<app-sharingdatatochild>
</app-sharingdatatochild><br/>
<input type="button" (click)="change_data()" value="Change Child Data"/>

ng g c sharingdatatochild

sharingdatatochild.component.ts
import { Component, Input, OnInit } from '@angular/core';

@Component({
  selector: 'app-sharingdatatochild',
  templateUrl: './sharingdatatochild.component.html',
  styleUrls: ['./sharingdatatochild.component.css']
})
export class SharingdatatochildComponent implements OnInit {

  empname: string="Rama";
  constructor() { }

  ngOnInit(): void {
  }

}

sharingdatatochild.component.html
<p>sharingdatatochild works!</p>
EMP NAME = {{empname}}

app.component.html
<app-sharingdata></app-sharingdata>


ViewChildren:-
------------------
The ViewChildren represents a set of elements of specific type, which is a child of the view (template) of the component.
ViewChildren is used to access elements, that is present in the view (template) of the component.
ViewChildren is used to access properties / methods of the children.

Steps:
	Import "ViewChildren" and "QueryList":
	import { ViewChildren,QueryList} from "@angular/core";
	
	Create ViewChildren property:
	class parentcomponent
	{
		@ViewChildren(classname) propertyname:QueryList<classname>;
		...
	}

	Access properties / methods of the child element, using ViewChildren's property:
	var array=this.propertyname.toArray();
	array[index].property
	array[index].method()

sharingdata.component.ts

import { Component, OnInit, QueryList, ViewChild, ViewChildren } from '@angular/core';
import { SharingdatatochildComponent } from '../sharingdatatochild/sharingdatatochild.component';

@Component({
  selector: 'app-sharingdata',
  templateUrl: './sharingdata.component.html',
  styleUrls: ['./sharingdata.component.css']
})
export class SharingdataComponent implements OnInit {
  //@ViewChild(SharingdatatochildComponent)
  //emp!: SharingdatatochildComponent;

  //@ViewChildren(classname) propertyname:QueryList<classname>;
  @ViewChildren(SharingdatatochildComponent)
  emp!:QueryList<SharingdatatochildComponent>;
  i:number=0;  
  constructor() { }

  ngOnInit(): void {

  }
  change_data()
  {
    // console.log(this.emp.empname);
    // this.emp.empname="Sita";
    // console.log(this.emp.empname);
    var array=this.emp.toArray();
  	//array[0].empname="Sairam";    
    for(;this.i<array.length;this.i++)
      array[this.i].empname="SitaRam";
  }
}

sharingdata.component.html

<p>sharingdata works!</p>

<app-sharingdatatochild>
</app-sharingdatatochild><br/>

<app-sharingdatatochild>
</app-sharingdatatochild><br/>

<app-sharingdatatochild>
</app-sharingdatatochild><br/>

<input type="button" (click)="change_data()" value="Change Child Data"/>

sharingdatatochild.component.ts

import { Component, Input, OnInit } from '@angular/core';

@Component({
  selector: 'app-sharingdatatochild',
  templateUrl: './sharingdatatochild.component.html',
  styleUrls: ['./sharingdatatochild.component.css']
})
export class SharingdatatochildComponent implements OnInit {

  empname: string="Rama";
  constructor() { }

  ngOnInit(): void {
  }

}
	
sharingdatatochild.component.html

<p>sharingdatatochild works!</p>
EMP NAME = {{empname}}

app.component.html
<app-sharingdata></app-sharingdata>

ContentChild
-----------------
The "contentchild" represents an element, which is a child of the content of the component.
contentchild is used to access an element, that is present in the content of the component.
contentchild can contain a child element of a specific type (class).
contentchild is used to access properties / methods of the child.

steps:
	Import "ContentChild":
	import { ContentChild } from "@angular/core";
	
	Create ContentChild Property:
	class parentcomponent
	{
		@ContentChild(classname) propertyname:classname;
		....
	}

	Access properties / methods of the element, using ContentChild's property:

	this.propertyname.property
	this.propertyname.method()

app.component.html
<app-sharingdata>
    <app-sharingdatatochild></app-sharingdatatochild>
</app-sharingdata>

sharingdata.component.ts

import { Component, ContentChild, OnInit, QueryList, ViewChild, ViewChildren } from '@angular/core';
import { SharingdatatochildComponent } from '../sharingdatatochild/sharingdatatochild.component';

@Component({
  selector: 'app-sharingdata',
  templateUrl: './sharingdata.component.html',
  styleUrls: ['./sharingdata.component.css']
})
export class SharingdataComponent implements OnInit {

  @ContentChild(SharingdatatochildComponent)
  emp!: SharingdatatochildComponent;


  constructor() { }

  ngOnInit(): void {

  }
  change_data()
  {
    console.log(this.emp.empname);
    this.emp.empname="Sita";
    console.log(this.emp.empname);
   }
}

sharingdata.component.html

<ng-content></ng-content>
<input type="button" (click)="change_data()" value="Change Child Data"/>

sharingdatatochild.component.ts

import { Component, Input, OnInit } from '@angular/core';

@Component({
  selector: 'app-sharingdatatochild',
  templateUrl: './sharingdatatochild.component.html',
  styleUrls: ['./sharingdatatochild.component.css']
})
export class SharingdatatochildComponent implements OnInit {

  empname: string="Rama";
  constructor() { }

  ngOnInit(): void {
  }

}

sharingdatatochild.component.html

<p>sharingdatatochild works!</p>
EMP NAME = {{empname}}

ContentChildren:-
---------------------
The ContentChildren represents a set of elements of specific type, which is a child of the content of the component. 
ContentChildren is used to access elements, that is present in the content of the component.
ContentChildren is used to access properties / methods of the children.

Steps:
	Import "ContentChildren" and "QueryList":
	import {ContentChildren,QueryList} from "@angular/core";

	Create Content Children Property:
	class parentcomponent
	{
		@ContentChildren(classname) propertyname:QueryList<classname>;
		...
	}

	Access properties / methods of the child element, using ContentChildren's property:
	var array=this.propertyname.toArray();
	array[index].property
	array[index].method()	


app.component.html

<app-sharingdata>
    <app-sharingdatatochild></app-sharingdatatochild>
    <app-sharingdatatochild></app-sharingdatatochild>
    <app-sharingdatatochild></app-sharingdatatochild>
</app-sharingdata>

sharingdata.component.ts

import { Component, ContentChild, ContentChildren, OnInit, QueryList, ViewChild, ViewChildren } from '@angular/core';
import { SharingdatatochildComponent } from '../sharingdatatochild/sharingdatatochild.component';

@Component({
  selector: 'app-sharingdata',
  templateUrl: './sharingdata.component.html',
  styleUrls: ['./sharingdata.component.css']
})
export class SharingdataComponent implements OnInit {
  //@ViewChild(SharingdatatochildComponent)
  //emp!: SharingdatatochildComponent;

  //@ViewChildren(classname) propertyname:QueryList<classname>;
  // @ViewChildren(SharingdatatochildComponent)
  // emp!:QueryList<SharingdatatochildComponent>;
  // i:number=0;  

  // @ContentChild(SharingdatatochildComponent)
  // emp!: SharingdatatochildComponent;

  @ContentChildren(SharingdatatochildComponent)
  emp!:QueryList<SharingdatatochildComponent>;
  i:number=0;  

  constructor() { }

  ngOnInit(): void {

  }
  change_data()
  {
    // console.log(this.emp.empname);
    // this.emp.empname="Sita";
    // console.log(this.emp.empname);
 

    var array=this.emp.toArray();
  	//array[0].empname="Sairam";    
    for(;this.i<array.length;this.i++)
      array[this.i].empname="SitaRam";
  }
}

sharingdata.component.html

<ng-content></ng-content>
<input type="button" (click)="change_data()" value="Change Child Data"/>


sharingdatatochild.component.ts

import { Component, Input, OnInit } from '@angular/core';

@Component({
  selector: 'app-sharingdatatochild',
  templateUrl: './sharingdatatochild.component.html',
  styleUrls: ['./sharingdatatochild.component.css']
})
export class SharingdatatochildComponent implements OnInit {

  empname: string="Rama";
  constructor() { }

  ngOnInit(): void {
  }

}

sharingdatatochild.component.html

<p>sharingdatatochild works!</p>
EMP NAME = {{empname}}


Reference Names:
-----------------------
Reference Names are used to access specific instance of the element in the template or content.
You can create the reference name by writing "#" and followed by reference name in the template.
You can access the element by specifying its reference name in the @ViewChild or @ContentChild decorator.
Syntax:
	Create reference name:
	<tag #referencename></tag>
		
	Access the element
	class parentcomponent
	{
	@ViewChild("referencename") propertyname:classname;
	@ContentChild("referencename") propertyname:classname;		
	....
	}

	Access properties / methods of the child element
	this.propertyname.property
	this.propertyname.method()

app.component.html

<app-sharingdata>    
</app-sharingdata>

sharingdata.component.ts

import { Component, ContentChild, ContentChildren, OnInit, QueryList, ViewChild, ViewChildren } from '@angular/core';
import { SharingdatatochildComponent } from '../sharingdatatochild/sharingdatatochild.component';

@Component({
  selector: 'app-sharingdata',
  templateUrl: './sharingdata.component.html',
  styleUrls: ['./sharingdata.component.css']
})
export class SharingdataComponent implements OnInit {

  @ViewChild("h") 
emp!:SharingdatatochildComponent;
	
  constructor() { }

  ngOnInit(): void {

  }
  change_data()
  {
    console.log(this.emp.empname);
    this.emp.empname="Sita";
    console.log(this.emp.empname);
 
  }
}

sharingdata.component.html

<p>sharingdata works!</p>

 <app-sharingdatatochild>
</app-sharingdatatochild><br/>

<app-sharingdatatochild #h>
</app-sharingdatatochild><br/>

<app-sharingdatatochild>
</app-sharingdatatochild><br/> 

<input type="button" (click)="change_data()" value="Change Child Data"/>

sharingdatatochild.component.ts

import { Component, Input, OnInit } from '@angular/core';

@Component({
  selector: 'app-sharingdatatochild',
  templateUrl: './sharingdatatochild.component.html',
  styleUrls: ['./sharingdatatochild.component.css']
})
export class SharingdatatochildComponent implements OnInit {

  empname: string="Rama";
  constructor() { }

  ngOnInit(): void {
  }

}

sharingdatatochild.component.html

<p>sharingdatatochild works!</p>
EMP NAME = {{empname}}

ElementRef
---------------
	ElementRef represents a specific normal tag (not a component) in the template / content.
	You can create the reference by writing # and followed by reference name in the template.
	You can access the element by specifying its reference name in the @ViewChild or 	@ContentChild decorator.
	
	Syntax: 
	Create reference name:
	<tag #referencename></tag>
	
	Access the element:
	class parentcomponent
	{
		@ViewChild("referencename") propertyname: ElementRef;
		@ContentChild("referencename") propertyname: ElementRef;
		.....
	}

	Access properties / methods of the child element:
	this.propertyname.property
	this.proertyname.method

sharingdata.component.ts
----------------------------------
import { Component, ContentChild, ContentChildren, ElementRef, OnInit, QueryList, ViewChild, ViewChildren } from '@angular/core';

@Component({
  selector: 'app-sharingdata',
  templateUrl: './sharingdata.component.html',
  styleUrls: ['./sharingdata.component.css']
})
export class SharingdataComponent implements OnInit {

  @ViewChild("h") p!:ElementRef;
  constructor() { }

  ngOnInit(): void {

  }
  change_data()
  {
     this.p.nativeElement.innerHTML="Sairam";
  }
}

sharingdata.component.html

<input type="button" (click)="change_data()" value="Change Child Data"/>
<div #h>Hi</div>

Life Cycle Hooks
--------------------
Component has a life cycle, which is managed by Angular.
Angular creates it, renders it, creates and renders its children, checks it when its properties changed, and destroys it before removing it from the DOM.
Angular offers lifecycle hooks that provide visibility into these key moments and the ability to act when they occur.
The life cycle events will execute automatically at different stages, while executing the component.

First Run:-
-----------
	1. Component Object:-
	---------------------------
	First, an object will be created for the component class. That means, the properties and methods 	of the component class, will be stored in the component object. 
	
	2. Constructor:-
	-------------------
	The Constructor of component class will be executed. Use the constructor, to set default values 	to any properties of the component, inject services into the component.

	3. OnChanges.ngOnChanges:-
	-------------------------------------
	ngOnChanges method of OnChanges interface will be executed. This method executes when a 	new object is received with the new values of the input properties and just before a moment of 	assigning those new values into the respective input properties of the component. This method 	executes, only if the component has input properties.

	4. OnInit.ngOnInit:-
	------------------------
	ngOnInit method of "OnInit" interface will be executed. Use this method to call services to get 	data from database or any other data source.

	5. DoCheck.ngDoCheck:-
	------------------------------
	ngDoCheck method of DoCheck interface will execute. This method executes when an event 	occurs, such as clickingm typing some key in the keyboard etc. Use this method to identify 	whether the change detection process occurs or not.

	6. AfterContentInit.ngAfterContentInit():
	----------------------------------------------------
	ngAfterContentInit method of AfterContentInit interface will execute. This method executes 	after initializing the content of the component, which is passed while invoking the component. 	Use this method to set the properties of content children.
	
	7. AfterContentChecked.ngAfterContentChecked():
	----------------------------------------------------------------
	ngAfterContentChecked method of AfterContentChecked interface will execute. This method 	executes after change detection process of the content is completed. Use this method to check 	any properties of the content children, whether those are having specific values or not.
	
	8. AfterViewInit.ngAfterViewInit():
	--------------------------------------------
	ngAfterViewInit method AfterViewInit interface will execute. This method executes after 	initializing the view (template) of the component. Use this method to set the properties of view 	children.

	9. AfterViewChecked.ngAfterViewChecked():
	---------------------------------------------------------
	ngAfterViewChecked method AfterViewInit interface will execute. This method executes after 	"change detection" process of view is completed. Use this method to check any properties of 	the view children, whether those are having specific values or not.

	On an event occurs
	------------------------
	1. DoCheck.ngDoCheck()
	2. AfterContentChecked.ngAfterContentChecked()
	3. AfterViewChecked.ngAfterViewChecked()

	On deleting the component:
	-----------------------------------
	OnDestroy.ngOnDestroy(): This method executes when the component is deleted from the 	memory (when we close the web page in the browser).

	Steps to handle event
	----------------------------
	1. Import the interface
	import { interfacename } from "@angular/core";
	
	2. Implement the interface
	export class componentclassname implements interfacename
	{
	}

	3. Create the method:
	methodname()
	{
	//code here
	}

	app.component.ts
	-----------------------
import { Component,OnInit,DoCheck,OnChanges,AfterContentInit,AfterContentChecked,AfterViewInit,AfterViewChecked,OnDestroy } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent implements OnInit, DoCheck,OnChanges,AfterContentInit,AfterContentChecked,AfterViewInit,AfterViewChecked,OnDestroy  {
  title = 'multiplemodules';
  constructor() {
    console.log("This is Constructor");
   }

  ngOnInit(): void {
    console.log("ngOnInit is Working");
  }
  ngDoCheck()
  {
    console.log("ngDoCheck is Working");
  }
  ngOnChanges(){
    console.log("ngOnChanges is Working");
  }
ngAfterContentInit()
{
  console.log("ngAfterContentInit is Working");
}
ngAfterContentChecked()
{
  console.log("ngAfterContentChecked is Working");
}
ngAfterViewInit()
{
  console.log("ngAfterViewInit is Working");
}
ngAfterViewChecked()
{
  console.log("ngAfterViewChecked is Working");
}
ngOnDestroy()
{
  console.log("ngOnDestroy is Working");
}
}

Services
-----------
The service is a class contains re-usable code (business logic, validations, calculations etc). Which can be called in one or more components. If you place the re-usable set of properties and methods as a service class, it can be called from any component or any other service in the entire application.

We must decorate the service class with @Injectable() decorator, to make the service accessible from any other compoent. You can import "@Injectable" decorator from "@angular/core" package.

We must use "@Inject()" decorator, to request angular to create an object for the service class. Then the angular framework will automatically creates an object for the service class and passes the object as argument for your component's constructor. You can receive it into a reference variable in the constructor.
You can use "@Inject" only in the constructor of component. To make the reference variable as member of the component class, add "private" or "public" keyword as left side of the reference variable in the constructor.
In realtime, all the CRUD operations (AJAX calls) are created in the service, the same is called in the component class, whenever required.

Steps to handle event:-
----------------------------
Create Service
------------------
import { Injectable } from "@angular/core";
@Injectable()
class Serviceclassname
{
methods here
}

Add service as provider in the component
----------------------------------------------------
@Component({...,providerss:[Serviceclassname]})
class ComponentClassname
{
}

(or) Add service as provider in the module
----------------------------------------------------
@NgModule({providers: [Serviceclassname]})
class ModuleClassname
{
}

Get the instance of service using dependency injection:
---------------------------------------------------------------------
import { Inject } from "@angular/core";
@Component({....})
class componentclassname
{
	constructor(@Inject(Serviceclassname) variable:Serviceclassname)
	{
	}
}

Services- Example
-----------------------

ng g cl user

export class User {
    username!:string;
    password!:string;
    constructor(uname:string,pword:string)
    {
        this.username=uname;
        this.password=pword;
    }
}

ng g s login

import { StringMap } from '@angular/compiler/src/compiler_facade_interface';
import { Injectable } from '@angular/core';
import { User } from './user';
@Injectable({
  providedIn: 'root'
})
export class LoginService {
user:User[]=[
new User("sai","sai"),
new User("sita","ram"),
new User("Durga","matha")
];
c:number=0;
  constructor() { }
compareunpw(un:string,pw:string)
{
for(var i=0;i<this.user.length;i++)
{
  if(this.user[i].username==un && this.user[i].password==pw)
    this.c++;
}
if(this.c==1)
return true;
else
return false;
}
}

app.module.ts

import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
					import { FormsModule } from '@angular/forms';
import { AppRoutingModule } from './app-routing.module';
import { AppComponent } from './app.component';
						import { LoginService } from './login.service';

@NgModule({
  declarations: [
    AppComponent
  ],
  imports: [
    BrowserModule,
    AppRoutingModule,
   						 FormsModule
  ],
						  providers: [LoginService],
  bootstrap: [AppComponent]
})

export class AppModule { }

App.component.ts
-------------------------
import { Component, Inject } from '@angular/core';
import { LoginService } from './login.service';
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'project1';
  username!:string;
  password!:string;
  msg:string="";
  constructor(@Inject(LoginService) public ls:LoginService){
  }
  do()
  {
    if(this.ls.compareunpw(this.username,this.password)==true)
        //this.msg="Login Success";
        console.log("Login Success");
      else
        //this.msg="Login Failed";
        console.log("Login Failed");
  }
}

App.component.html

<table>
    <tr>
        <th colspan="2">LOGIN PAGE</th>
    </tr>
    <tr>
        <td>User Name:</td>
        <td><input type="text" id="username" [(ngModel)]="username" /></td>
    </tr>
    <tr>
        <td>Pass Word:</td>
        <td><input type="password" id="password" [(ngModel)]="password" /></td>
    </tr>
    <tr>
        <td colspan="2"><input type="button" value="Sign In" (click)="do()" /></td>
    </tr>
</table>
<div [innerHTML]="msg"></div>

Sharing Data using Services
-----------------------------------
We can't share data among sibling components directly, but we can do it by using service.
We can set data from component1 to service. then the component2 can access data from service.

ng g c India

ng g c Usa

ng g s Population

app.module.ts
-------------------
import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { PopulationService } from './population.service';

import { AppComponent } from './app.component';
import { IndiaComponent } from './india/india.component';
import { UsaComponent } from './usa/usa.component';

@NgModule({
  declarations: [
    AppComponent,
    IndiaComponent,
    UsaComponent
  ],
  imports: [
    BrowserModule
  ],
  providers: [PopulationService],
  bootstrap: [AppComponent]
})
export class AppModule { }


app.component.html
---------------------------
<div>
  <h2>Sharing Data Using Services</h2>
  <app-india></app-india>
  <app-usa></app-usa>
</div>

population.service.ts
--------------------------
import { Injectable } from '@angular/core';

@Injectable({
  providedIn: 'root'
})
export class PopulationService {
  IndiaPopulation:number;
  constructor() { }
}

india.component.ts
-------------------------
import { Component, Inject, OnInit } from '@angular/core';
import { PopulationService } from '../population.service';

@Component({
  selector: 'app-india',
  templateUrl: './india.component.html',
  styleUrls: ['./india.component.css']
})
export class IndiaComponent implements OnInit {
  
  population:number=1.32;
  
  constructor(@Inject(PopulationService) private ps:PopulationService) 
  { 
    this.ps.IndiaPopulation=this.population;
  }

  ngOnInit(): void {
  }

}

usa.component.ts
-----------------------
import { Component, Inject, OnInit } from '@angular/core';
import { PopulationService } from '../population.service';

@Component({
  selector: 'app-usa',
  templateUrl: './usa.component.html',
  styleUrls: ['./usa.component.css']
})
export class UsaComponent implements OnInit {

  ip:number;
  constructor(@Inject(PopulationService)private ps:PopulationService)
   {
    this.ip=this.ps.IndiaPopulation;
   }

  ngOnInit(): void {
  }

}

usa.component.html
--------------------------
<h2>India Population: {{ip}} billion.</h2>

Custom Directives
-----------------------
Directive is a class, that can be invoked (called) through an attribute of a tag in the template.
Directive provides additional functionality for the html element.
For example, "ngIf" directive checks the condition, displays the element if the condition is true, and removes the element if the condition is false.
The "ElementRef" class represents the element, in which the directive is invoked.
Directive can receive values from the element using @Input() decorator.
Directive can add events to the element by using @HostListener() decorator.
We can communicate between the component to the directive, using @ViewChild decorator in the component.

Steps for working with Directives
-----------------------------------------
Create directive:
	@Directive({selector: "[directiveattributename]"})
	class directiveclassname
	{
		constructor(@Inject(ElementRef) referencename:ElementRef)
		{
		}	
	}
	@Input() directiveproperty: datatype;
	
	@HostListener("eventname")
	methodname()
	{
	}
	}

Add directive to the module:
	@NgModule({...,declarations:[...,directiveclassname]})	
	class moduleclassname
	{
	}

Invoke directive from html tag:
	<tag directiveattributename directiveproperty="value"></tag>

ng g d Sample

sample.directive.ts
------------------------
import { Directive,Inject,ElementRef } from '@angular/core';

@Directive({
  selector: '[appSample]'
})
export class SampleDirective  {

  constructor(@Inject(ElementRef) private element:ElementRef) 
  { 
    this.element.nativeElement.style.border="1px solid blue";
  }
}

app.component.html
---------------------------
<div>
  <h4>Custom Directives</h4>
  <p appSample>Welcome to Custom Directives</p>
</div>

Pipes
-------
Pipes transforms the value into user-expected format.
Pipes are invoked in expressions (interpollation binding), through pipe (|) symbol. 
Syntax: {{property | pipe}}}

actual value -> pipe -> output value

List of Built-in pipes
-------------------------
1. uppercase
2. lowercase
3. slice
4. number
5. currency
6. percent
7. date
8. json


app.component.ts
------------------------
import { Component } from '@angular/core';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  title = 'pipesexample';
  city:string="Nellore";
  salary:number=12000;
  n:number=0.72;
  person:object={"firstname":"rama","lastname":"sita"};
  dt:Date=new Date();
}

app.component.html
---------------------------
<div class="class1">
  <h2>Pipes</h2>

  City: {{city}}<br/>
  Upper Case City is : {{city}}<br/>
  Lower Case City is : {{city}}<br/>
  Slice: {{city | slice:2:6}}<br/>
<hr/>
  Salary: {{salary}}<br/>
  Salary (.2) :  {{salary|number:".2"}}<br/>
Salary Currency: {{salary | currency:"INR"}}<br/>
Salary Currency: {{salary | currency:"INR"}}<br/>
Salary Currency: {{salary | currency:"USD"}}<br/>
Salary Currency: {{salary | currency:"EUR"}}<br/>
Salary Currency: {{salary | currency:"GBP"}}<br/>
<hr/>
n: {{n}}<br/>
n: {{n | percent}}<br/>
<hr/>
  Person: {{person}}<br/>
  JSON: {{person | json}}<br/>
  <hr/>
  Current Time: {{dt}}<br/>
  Short Date: {{dt|date:"shortDate"}}<br/>
  Medium Date: {{dt|date: "mediumDate"}}<br/>
  Long Date: {{dt|date: "longDate"}}<br/>
  Full Date: {{dt|date:"fullDate"}}<br/>
  Short Time: {{dt|date:"shortTime"}}<br/>
  Long Time: {{dt|date:'mediumTime'}}<br/>
  Short: {{dt|date:"short"}}<br/>
  Medium: {{dt|date:"medium"}}<br/>
  d/M/y: {{dt|date:"d/M/y"}}<br/>
  y-M-d: {{dt|date:"y-M-d"}}<br/>
  h:m:s: {{dt|date:"h:m:s"}}<br/>
  H:m: {{dt|date:"H:m"}}<br/>
  a: {{dt|date:"a"}}<br/>
  EEE: {{dt|date:"EEE"}}<br/>
  EEEE: {{dt|date:"EEEE"}}<br/>
  MMM: {{dt|date:"MMM"}}<br/>
  MMMM: {{dt|date:"MMMM"}}<br/>
  Z: {{dt| date:"Z"}}
</div>

Custom Pipes:
Custom Pipes are the User-defined pipes.
Custom pipe must be a class that has @Pipe() decorator and implments "PipeTransform" interface.
The "PipeTransform" interface has "transform" method, which must be implemented in your pipe class.
The "transform" method will be executed automatically, when the pipe is invoked in the expression (through pipe(|) symbol).
The "transform" method receive the input value as argument, do process, and return the result value, which will be displayed in the output.
Syntax to call pipe: {{ property|pipe }}

actual value -> pipe -> output value

Syntax of Custom pipe
-----------------------------

import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'namehere'
})
export class customPipeclassname implements PipeTransform {

  transform(value: unknown, ...args: unknown[]): unknown {
    return null;
  }

}

Add Pipe to the module:
------------------------------
@NgModule({...,declarations: [custompipeclassname],...})
class moduleclassname
{
....
}

Invoke the pipe in the template:

{{componentproperty|pipename}}

ng g p Square

square.pipe.ts
------------------
import { Pipe, PipeTransform } from '@angular/core';

@Pipe({
  name: 'square'
})
export class SquarePipe implements PipeTransform {

  transform(num: number): number {
    return num*num;
  }

}

app.component.html
---------------------------
Square of 5 is {{5 | square}}

Forms and Validations
----------------------------
Forms are 2 types

1. Template Driven Forms
	Template Driven Forms are suitable for development of simple forms with limited no.of fileds and 	simple validations.
	In these forms, each field is represented as a property in the component class.
	Validations rules are defined in the template, using "html 5" attributes. Validation messages are 
	displayed using "validation properties" of angular.
	"FormsModule" should be imported from "@angular/forms" package.

	HTML5 attributes for validations:
		required="required"	:	Field is mandatory
		minlength="n"	:	Minimum no.of characters
		pattern="reg exp"	:	Regular expression

	Validation Properties:
		untouched
			true	:	Field is not focused.
			false	:	Field is focused.
		
		touched
			true	:	Field is focused.
			false	:	Field is not focused.

		pristine
			true	:	Field is not modified by the user.
			false	:	Field is modified by the user.

		dirty
			true	:	Field is modified by the user.
			false	:	Field is not modified by the user.
	
		valid
			true	:	Field value is valid.
			false	:	Field value is invalid.
		
		invalid	
			true	:	Field value is invalid.	
			false	:	Field value is valid.		
			
		errors		:	Represents the list of errors of the field.
			required	:	true/false
			minlength:	true/false
			pattern	:	true/false
			number	:	true/false
			email	:	true/false
			url	:	true/false

SNo.	Description			Regular Expression
1.	Digits only			^[0-9]*$
2.	Alphabets only			^[a-zA-Z]*$
3.	Indian Mobile Number		^[6789]\d{9}$
4. 	Email			
5. 	Usernames: Alphabets, Digits and Hyphens only.	([A-Za-z0-9-]+)
6. 	Passwords: 6 to 15 characters;			((?=.*\d)(?=.*[a-z])(?=.*[A-Z].{6,15})
	atleast one uppercase letter, one lowercase letter
	and one digit. 

	Create a Simple Template Driven Form with form validations.
	
	First Name
	Last Name
	Email
	Amount
	Gender
	Country

ng g c templatedriven
app.module.ts

import { FormsModule } from '@angular/forms';
imports:
[
FormsModule
]

app.component.ts

	firstname:string=null;
	lastname:string=null;
	email:string=null;
	amount:string=null;
	gender:string=null;
	country:string="";
	msg:string=null;
	onRegisterClick(f)
	{
		if(f.valid)
		{
			this.msg="First Name : "+this.firstname+"<br/> Last Name : "+this.lastname+"<br/> Email : "+this.email+"<br/>Amount : "+this.amount+"<br/> Gender : "+this.gender+"<br/> Country : "+this.country;	
		}		
		else
		this.msg="invalid";
	}		

app.component.html
<div class="class1">
<h4>Template Driven Forms</h4>
<form #myform="ngForm">
FirstName:
<input type="text" [(ngModel)]="firstname" name="firstname" required minlength="3" maxlength="20" pattern="^[a-zA-Z]*$" #control1="ngModel"/>
<span class="error" *ngIf="control1.touched && control1.invalid && control1.errors.required"/>First Name Cannot be blank.</span>
<span class="error" *ngIf="control1.touched && control1.invalid && control1.errors.minlength">Min: 3 characters </span>
<span class="error" *ngIf="control1.touched && control1.invalid && control1.errors.pattern">Alphabets only allowed</span>
<br/>
LastName:
<input type="text" [(ngModel)]="lastname" name="lastname" required minlength="3" maxlength="20" pattern="^[a-zA-Z]*$" #control2="ngModel"/>
<span class="error" *ngIf="control2.touched && control2.invalid && control2.errors.required"/>Last Name Cannot be blank.</span>
<span class="error" *ngIf="control2.touched && control2.invalid && control2.errors.minlength">Min: 3 characters </span>
<span class="error" *ngIf="control2.touched && control2.invalid && control2.errors.pattern">Alphabets only allowed</span>
<br/>
Email:
<input type="text" [(ngModel)]="email" name="email" required pattern="" #control3="ngModel"/>
<span class="error" *ngIf="control3.touched && control3.invalid && control3.errors.required"/>Email Cannot be blank.</span>
<span class="error" *ngIf="control3.touched && control2.invalid && control2.errors.pattern">Email is not  valid</span>
<br/>
Amount:
<input type="text" [(ngModel)]="amount" name="amount" required pattern="^[0-9]*$" #control4="ngModel"/>
<span class="error" *ngIf="control4.touched && control4.invalid && control4.errors.required"/>Amount  Cannot be blank.</span>
<span class="error" *ngIf="control4.touched && control4.invalid && control4.errors.pattern">Alphabets not  allowed</span>
<br/>
Gender:
<input type="radio" [(ngModel)]="gender" name="gender" value="male" required #control5="ngModel"/>
<input type="radio" [(ngModel)]="gender" name="gender" value="female" required #control5="ngModel"/>
<span class="error" *ngIf="control5.touched && control5.invalid && control5.errors.required"/>Please select gender.</span>
<br/>
Country:
	<select [(ngModel)]="country" name="country" required #control6="ngModel">
	<option>..Select..</option>
	<option>India</option>
	<option>USA</option>
	<option>UK</option>
	<option>JAPAN</option>
	</select>
<br/>
<input type="submit" value="Register" (click)="onRegisterClick(myform)"/><br/>
<div [innerHTML]="msg"></div>
</form>
</div>

styles.css
input.ng-invalid.ng-touched
{
border:2px solid red;
}
input.ng-valid.ng-touched
{
border:2px solid green;
}
.error
{
color:red;
}

Reactive Forms ( or ) Model Driven Forms
---------------------------------------------------
Reactive Forms (or) Model Driven Forms are new type of forms in angular, which are suitable for creating large forms with many fields and complex validations.
In these forms, each field is represented as "FormControl" and group of controls is represented as "FormGroup".
ReactiveFromsModule should be imported from "@angular/forms" package.
Validation rules are defined in the component using "Validators" object of angular and validation messages are displayed in the template using "validation properties" of angular.

Validations in Reactive Forms:
	Validators.required		:	Field is mandatory.
	Validators.minLength	:	Minimum no.of characters.
	Validators.maxLength	:	Maximum no.of characters.
	Validators.pattern		:	Regular Expression

Validation Properties:
	untouched	
		true	:	Field is not focused.
		false	:	Field is focused.
	touched
		true	:	Field is focused.	
		false	:	Field is not focused.
	pristine
		true	:	Field is not modified by the user.
		false	:	Field is modified by the user.
	dirty	
		true	:	Field is modified by the user.
		false	:	Field is not modified by the user.
	valid	
		true	:	Field value is valid.
		false	:	Field value is not valid.
	invalid
		true	:	Field value is not valid.
		false	:	Field value is valid.

	errors	:	Represents the list of errors of the field.
		required		:	true/false
		minlength	:	true/false
		maxlength	:	true/false
		pattern		:	true/false
		


app.module.ts
	import { ReactiveFormsModule } from '@angular/forms'; 

	imports:[ReactiveFormsModule]

app.component.ts

import { FormGroup, FormControl, Validators } from "@angular/forms";

msg:string="";
myform:FormGroup;
constructor()
{
	this.myform=new FormGroup({
		firstname:new FormControl("",[Validators.required,Validators.minLength(3),Validators.maxLength(20),Validators.pattern("^[a-zA-Z]*$")]),
		lastname:new FormControl("",[Validators.required,Validators.minLength(3),Validators.maxLength(20),Validators.pattern("^[a-zA-Z]*$")]),
		email:new FormControl("",[Validators.required,Validators.pattern("")]),
		amount:new FromControl("",[Validators.required,Validators.pattern("^[0-9]*$")]),
		gender:new FormControl("",[Validators.required]),
		country:new FormControl("",[Validators.required])
	});
}

	onRegisterClick()
	{
		if(this.myform.valid)
		{
			this.msg="First Name : "+this.myform.controls.firstname.value+"<br/> Last Name : "+this.myform.controls.lastname.value+"<br/> Email : "+this.myform.controls.email.value+"<br/>Amount : "+this.myform.controls.amount.value+"<br/> Gender : "+this.myform.controls.gender.value+"<br/> Country : "+this.myform.controls.country.value;	
		}		
		else
		this.msg="invalid";
	}		



app.component.html

<div class="class1">
<h4>Reactive Forms</h4>
<form [formGroup]="myform">
FirstName:
<input type="text" formControlName="firstname"/>
<span class="error" *ngIf="myform.controls.firstname.touched && myform.controls.firstname.invalid && myform.controls.firstname.errors.required"/>First Name Cannot be blank.</span>
<span class="error" *ngIf="myform.controls.firstname.touched && myform.controls.firstname.invalid && myform.controls.firstname.errors.minlength">Min: 3 characters </span>
<span class="error" *ngIf="myform.controls.firstname.touched && control1.invalid && myform.controls.firstname.errors.pattern">Alphabets only allowed</span>
<br/>
LastName:
<input type="text" formControlName="lastname"/>
<span class="error" *ngIf="myform.controls.lastname.touched && myform.controls.lastname.invalid && myform.controls.lastname.errors.required"/>Last Name Cannot be blank.</span>
<span class="error" *ngIf="myform.controls.lastname.touched && myform.controls.lastname.invalid && myform.controls.lastname.errors.minlength">Min: 3 characters </span>
<span class="error" *ngIf="myform.controls.lastname.touched && myform.controls.lastname.invalid && myform.controls.lastname.errors.pattern">Alphabets only allowed</span>
<br/>
Email:
<input type="text" formControlName="email"/>
<span class="error" *ngIf="myform.controls.email.touched && myform.controls.email.invalid && myform.controls.email.errors.required"/>Email Cannot be blank.</span>
<span class="error" *ngIf="myform.controls.email.touched && myform.controls.email.invalid && myform.controls.email.errors.pattern">Email is not  valid</span>
<br/>
Amount:
<input type="text" formControlName="amount"/>
<span class="error" *ngIf="myform.controls.amount.touched && myform.controls.amount.invalid && myform.controls.amount.errors.required"/>Amount  Cannot be blank.</span>
<span class="error" *ngIf="myform.controls.amount.touched && myform.controls.amount.invalid && myform.controls.amount.errors.pattern">Alphabets not  allowed</span>
<br/>
Gender:
<input type="radio" formControlName="gender" value="male"/>
<input type="radio" formControlName="gender" value="female"/>
<span class="error" *ngIf="myform.controls.gender.touched && myform.controls.gender.invalid && myform.controls.gender.errors.required"/>Please select gender.</span>
<br/>
Country:
	<select formControlName="country">
	<option>..Select..</option>
	<option>India</option>
	<option>USA</option>
	<option>UK</option>
	<option>JAPAN</option>
	</select>
<span class="error" *ngIf="myform.controls.country.touched && myform.controls.country.invalid && myform.controls.country.errors.required"/>Please select gender.</span>	
<br/>
<input type="submit" value="Register" (click)="onRegisterClick()"/><br/>
<div [innerHTML]="msg"></div>
</form>
</div>

styles.css
input.ng-invalid.ng-touched
{
border:2px solid red;
}
input.ng-valid.ng-touched
{
border:2px solid green;
}
.error
{
color:red;
}

Routing
----------
The routing concept is used to create page navigation in angular application.
Routing includes the process of mapping between the route (url) and corresponding component. 

The @angular/router package provides essential API to create routing.

steps:

import  { Routes }  from "@angular/router";

Create routes:
	var variable1:Routes:[
		{path:"path here",component:ComponentClassName},
		{path:"path here",component:ComponentClassName},
		{path:"path here",component:ComponentClassName},
		{path:"path here",component:ComponentClassName},
		...
	];

Import RouterModule from "@angular/router" package:
import { RouterModule } from "@angular/router";
 
Create hyperlink to route:
	<a routerLink="/path">Link Text</a>

Create Placeholder to display route content:
	<router-outlet>
	</router-outlet>

Ex:
ng g c Home
ng g c About
ng g c Contact

app-routing.module.ts
import  { Routes,RouterModule }  from "@angular/router";

var myroutes:Routes=[
	{path:"",component:HomeComponent},
	{path:"home",component:HomeComponent},
	{path:"about",component:AboutComponent},
	{path:"contact",component:ContactComponent}
];

app.component.html
<div>
	<h4>Routing</h4>
	<a routerLink="home">HOME</a>
	<a routerLink="about">ABOUT US</a>
	<a routerLink="contact">CONTACT US</a>
	<div id="container">
		<router-outlet>
		</router-outlet>
	</div>
</div>

Route Parameters
-----------------------
You can pass  parameters to the route.
Route parameter is represented as ":parametername" syntax.
You can get the value of the parameter in the component using "ActivatedRoute" service.

Steps for Working with Route Parameters
	Create parameter in the route:
		{path:"pathname/:parametername",component:Componentclassname},
	
	Import the "ActivatedRoute" Service:
	import { ActivatedRoute } from "@angular/router";
	
	Get the object of "ActivatedRoute" service:
	constructor(@Inject(ActivatedRoute) private route:ActivatedRoute)
	{
	}

	Get the value of parameter:
	this.route.snapshot.params["parametername"]

	(or) 
	Get the value of parameter with updates:
	this.route.params.subscribe(params=>
	{
		params["parametername"]
	});


	ng g c Products
	ng g cl Product
	ng g s Products


product.ts
export class Product
{
	productId:number;
	productName:string;
	cost:number;
	brand:string;
	constructor(productId:number,productName:string,cost:number,brand:string)
	{
		this.productId=productId;
		this.productName=productName;
		this.cost=cost;
		this.brand=brand;
	}
}


products.service.ts
import { Product } from "./product";

@Inejctable()
export class ProductsService
{
products:Product[];
constructor()
{
	this.products=[
		new Product(100,"Samsung S8",49000,"Samsung"),
		new Product(101,"Samsung S9",63000,"Samsung"),
		new Product(102,"iPhone 8",69000,"Apple"),
		new Product(103,"iPhone 10",59000,"Apple"),
		new Product(104,"Pixel 2",42000,"Google"),
		new Product(105,"Pixel 3",89000,"Google")
	];
}
getProductsByBrand(brandName:string):Product[]
{
	var selectedProducts:Product[]=[];
	for(var i=0;i<this.products.length;i++)
	{
		if(this.products[i].brand==brandName)
			selectedProducts.brand(this.products[i]);
	}
	return selectedProducts;
}
}

app-routing.module.ts

var myroutes:Routes=[
{path:"",component:HomeComponent},
{path:"home",component:HomeComponent},
{path:"about",component:AboutComponent},
{path:"contact",component:ContactComponent},
{path:"products/:brandname",component:ProductsComponent},
];

app.component.html

<h3>Routing</h3>
<a routerLink="home">HOME</a>
<a routerLink="about">ABOUT</a>
<a routerLink="contact">CONTACT</a>
<a routerLink="products/Samsung">Samsung</a>
<a routerLink="products/Apple">Apple</a>
<a routerLink="products/Google">Google</a>

<div id="container">
	<router-outlet>
	</router-outlet>
</div>

products.component.ts
-----------------------------
import { Product } from '../product'; 
import { ProductsService } from '../products.service'; 
import { ActivatedRoute} from "@angular/router";

brand:string;
matchingproducts:Product[]=[];
constructor(@Inject(ProductsService) private prodService:ProductsService,@Inject(ActivatedRoute) private route:ActivatedRoute)
{
}
}

ngOnInit()
{
this.route.params.subscribe(params=>{
	var selectedBrand=params["brandname"];
	this.brand=selectedBrand;
	this.matchingproducts=this.prodService.getProductsByBrand(selectedBrand);
});
}


products.component.html
<div>
	<h2>Products</h2>
	<h3>{{brand}}</h3>
	<table border="1">
		<tr>
			<th>Product ID</th>
			<th>Product NAME</th>
			<th>Cost</th>
			<th>Brand</th>
		</tr>
		<tr *ngFor="let product of matchingproducts">
				<td>{{product.productId}}</td>
				<td>{{product.productName}}</td>
				<td>{{product.cost}}</td>
				<td>{{product.brand}}</td>
		</tr>
	</table>
	<a routerLink="/home">Back to Home</a>
</div>

Child Routes:
-----------------
Route can have child routes up to unlimited no.of nested levels.
	Ex: "FundsTransfer" menu has "Transfer","AddPayee","ActivatePayee" etc.

Steps for Working with ChildRoutes:
	Create Child Routes:
		{
			{path:"parentPath",component:componentClassname,children:{
				{path:"childpath",component:componentClassname},
				{path:"childpath",component:componentClassname},
				{path:"childpath",component:componentClassname},
				.....
			}
		}

Create hyperlink for the child route:
	<a href="/parentpath/childpath">Link Text</a>

Create router outlet for child routes (in the parent route component's template):
<router-outlet></router-outlet>

program in src zip folder

Guards:-
---------
The Guard is a service that executes at the specified situation while angular is navigating from one route to another route.
Angular mainly supports two types of guards:
	CanActivate: Executes before entering into a route.
	CanDeactivate: Executes before leaving a route.

CanActivate:
	The "CanActivate" Guard executes before entering into a route.
	Process: User clicks on the hyperlink -> Identify the route -> CanActivate Guard -> Navigate to the 	Route -> Corresponding component.
	This guard can be created by implementing "CanActivate" interface.
	The "CanActivate" interface has a method called "CanActivate". This method must return a 	boolean value, which indicates whether the route can be navigated or not. If we return true, the 	route will be navigated, if we return false, the route navigation will be stopped.
	It can receive an argument of "ActivatedRouteSnapshot" type, which represents the current 	state of the route.
	
Steps for Working with CanActivate:
	Import "CanActivate" interface from "@angular/router" package:
	import { CanActivate, ActivatedRouteSnapshot } from "@angular/router";

	Create a Service that implements "CanActivate" interface:
	class Serviceclassname implements CanActivate
	{
		canActivate(route:ActivatedRouteSnapshot): boolean
		{
			return true / false;		
		}
	}

	Add service to the module:
	@NgModule({..,providers:[ServiceClassname]})	

	Add guard to the route:
	{path:"path here", component:ComponentClassname,canActivate:[Serviceclassname]}
		
program in src zip folder

CanDeactivate:
	The "CanDeactivate" Guard executes before leaving from a route.
	This guard can be created by implementing "CanDeactivate" interface.
	The "CanDeactivate" interface has a method called "canDeactivate". This method must return a 	boolean value, which indicates whether the route can be leave or not. If we return "true", the 	route will be left; if we return false, the route navigation will be stopped.
	It can receive an argument of an user-defined interface type, which represents the current 	component.
	
Steps for Working with CanDeactivate:
	Import "CanDeactivate" interface from "@angular/router" package:
	Import { CanDeactivate } from "@angular/router";

	Create the interface for CanDeactive Guard:
	interface interfacename
	{
		canNavigate:boolean;
	}
	
	Create a Service that implements "CanDeactivate" interface:
	class Serviceclassname implements CanDeactivate<interfacename>
	{
		canDeactivate(component:interfacename):boolean
		{
			return true / false;
		}
	}	

	Add service to the module:
	@NgModule({..,providers:[ServiceClassName]})

	Add guard to the route:
	{path: "path here",component:ComponentClassname,canDeactivate: [ServiceClassname]}

Ex:
ng g c Home
ng g c About
ng g c Contact
ng g cl CanComponentDeactivate
ng g s CanDeactivateGuard

export interface CanComponentDeactivate
{
	canNavigate:boolean;
}

can-deactivate-guard.service.ts
import { Injectable } from "@angular/core";
import { CanDeactivate } from "@angular/router";
import { CanComponentDeactivate } from './can-component-deactivate'; 

export class CanDeactivateGuardService implements CanDeactivate<CanComponentDeactive>
{
canDeactivate(component:CanComponentDeactivate)
{
	if(component.canNaviagate==true)
	{
		return true;
	}
	else
	{
		if(confirm("Do You want to discard changes?"))
			return true;
		else
			return false;
	}
}
}

app.module.ts
providers:[CanDeactivateGuardService]

app-routing.module.ts
import  { Routes,RouterModule }  from "@angular/router";

var myroutes:Routes=[
	{path:"",component:HomeComponent},
	{path:"home",component:HomeComponent,canDeactivate:[CanDeactivateGuardService]},
	{path:"about",component:AboutComponent},
	{path:"contact",component:ContactComponent}
];

app.component.html
<div>
	<h4>Routing</h4>
	<a routerLink="home">HOME</a>
	<a routerLink="about">ABOUT US</a>
	<a routerLink="contact">CONTACT US</a>
	<div id="container">
		<router-outlet>
		</router-outlet>
	</div>
</div>


home.component.ts
	firstname:string=null;
	lastname:string=null;
	canNavigate:boolean=true;
	onFirstNameChange()	
	{
		this.canNavigate=false;
	}	
	onLastNameChange()
	{
		this.canNavigate=true;
	}

	onSave()
	{
		this.canNavigate=true;
		alert("Record Saved");
	}


home.component.html
	<div>
		<h5>Home</h5>
		FirstName: <input type="text" (change)="onFirstNameChange()"/><br/>
		LastName: <input type="text" (change)="onLastNameChange()"/><br/>
		<input type="submit" value="Save" (click)="onSave()"/>
	</div>

RxJs:-
-------
Observable and Observer 
	Observable is a data source ( User Events, Http requests, Custom Data Source), which emits data 	packets to the observer.
	Observer is an object that subscribes to the observable and listens to the data packets that are 	sent by observables.
Data Flow:
	Observable emits (sends) data to the observer. Everytime it emits data, the corresponding callback function automatically executes in observer.
	
Types of Callback functions in Observer:
-------------------------------------------------
HandleData Callback: It executes when the next data packet has been emitted by the observable.
HandleError Callback: It executes when error emitted by the observable. If this is invoked, the observable stream ends; that means, no other callback functions are invoked further.
HandleCompletion Callback: It executes when observable indicates steam completion. If this is invoked, the  observable stream ends; that means, no other callback functions are invoked further.

Creating Observable:
	Import "Observable"
		import { Observable } from "rxjs";

CRUD PROJECT with AJAX CALLS and RXJS

ng g c employee

employee.ts

export class Employee {
    id:number;
    firstName:string;
    lastName:string;
    emailId:string;
    active:boolean;
}

ng g s employee

employee.service.ts

import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class EmployeeService {
private baseUrl="http://localhost:3000/employee";

constructor(private http:HttpClient) { }
getEmployeeList():Observable<any>
{
  return this.http.get(`${this.baseUrl}`);
}
getEmployee(id:number):Observable<any>{
  return this.http.get(`${this.baseUrl}/${id}`);
}
deleteEmployee(id:number):Observable<any>
{
  return this.http.delete(`${this.baseUrl}/${id}`,{responseType:'text'});
}
updateEmployee(id:number,value:any):Observable<Object>
{
  return this.http.put(`${this.baseUrl}/${id}`,value);
}
createEmployee(employee:Object):Observable<Object>
{
  return this.http.post(`${this.baseUrl}`,employee);
}
}

app.module.ts

import { NgModule } from '@angular/core';
import { BrowserModule } from '@angular/platform-browser';
import { FormsModule} from '@angular/forms';
import { HttpClientModule } from '@angular/common/http';
import { AppRoutingModule } from './app-routing.module';
import { AppComponent } from './app.component';
import { EmployeeListComponent } from './employee-list/employee-list.component';
import { CreateEmployeeComponent } from './create-employee/create-employee.component';
import { EmployeeDetailsComponent } from './employee-details/employee-details.component';
import { UpdateEmployeeComponent } from './update-employee/update-employee.component';

@NgModule({
  declarations: [
    AppComponent,
    EmployeeListComponent,
    CreateEmployeeComponent,
    EmployeeDetailsComponent,
    UpdateEmployeeComponent
  ],
  imports: [
    BrowserModule,
    AppRoutingModule,
    HttpClientModule,
    FormsModule
  ],
  providers: [],
  bootstrap: [AppComponent]
})
export class AppModule { }

app.component.html
<a routerLink="employees">Employee List</a>
<br/>
<a routerLink="add">Add New Employee</a><br/>
<router-outlet></router-outlet>

app-routing.module.ts

import { NgModule } from '@angular/core';
import { RouterModule, Routes } from '@angular/router';
import { CreateEmployeeComponent } from './create-employee/create-employee.component';
import { EmployeeDetailsComponent } from './employee-details/employee-details.component';
import { EmployeeListComponent } from './employee-list/employee-list.component';
import { UpdateEmployeeComponent } from './update-employee/update-employee.component';

const routes: Routes = 
[
  {path:'',redirectTo:'employees',pathMatch:'full'},
  {path:'employees',component:EmployeeListComponent},
  {path:'details/:id',component:EmployeeDetailsComponent},
  {path:'add',component:CreateEmployeeComponent},
  {path:'update/:id',component:UpdateEmployeeComponent}
];

@NgModule({
  imports: [RouterModule.forRoot(routes)],
  exports: [RouterModule]
})
export class AppRoutingModule { }

employee-list.component.ts

import { typeWithParameters } from '@angular/compiler/src/render3/util';
import { Component, OnInit } from '@angular/core';
import { Router } from '@angular/router';
import { Observable } from 'rxjs';
import { Employee } from '../employee';
import { EmployeeService } from '../employee.service';

@Component({
  selector: 'app-employee-list',
  templateUrl: './employee-list.component.html',
  styleUrls: ['./employee-list.component.css']
})
export class EmployeeListComponent implements OnInit {
employees:Observable<Employee[]>;
  constructor(private empService:EmployeeService,private router:Router) 
  { 
  }

  ngOnInit(): void {
    this.reload();
  }
  reload()
  {
    this.employees=this.empService.getEmployeeList();
  }
  employeedetails(id:number)
  {
    this.router.navigate(['details',id]);
  }
  deleteemployee(id:number)
  {
    this.empService.deleteEmployee(id).subscribe(data=>{this.reload()},
    error=>{console.log(error);}
    )
  }
  updateemployee(id:number)
  {
    this.router.navigate(['update',id]);
  }
}

employee-list.component.html
<!-- <p>employee-list works!</p> -->

<div class="panel panel-body">
    <table class="table table-striped">
        <thead>
            <tr>
                <th>EMP ID</th>
                <th>EMP FIRST NAME</th>
                <th>EMP LAST NAME</th>
                <th>EMAIL</th>
                <th>ACTIONS</th>
            </tr>
        </thead>
        <tbody>
            <tr *ngFor="let e of employees | async">
                <td>{{e.id}}</td>
                <td>{{e.firstName}}</td>
                <td>{{e.lastName}}</td>
                <td>{{e.emailId}}</td>
                <td><button (click)="employeedetails(e.id)" class="btn btn-info">Details</button>
                    <button (click)="deleteemployee(e.id)" class="btn btn-info">Delete</button>
                    <button (click)="updateemployee(e.id)" class="btn btn-info">Update</button>
                </td>
            </tr>
        </tbody>
    </table>
</div>

update-employee.component.ts

import { Component, OnInit } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { Employee } from '../employee';
import { EmployeeService } from '../employee.service';

@Component({
  selector: 'app-update-employee',
  templateUrl: './update-employee.component.html',
  styleUrls: ['./update-employee.component.css']
})
export class UpdateEmployeeComponent implements OnInit {
 id: number;
 employee:Employee;
  constructor(private route:ActivatedRoute,private router:Router,private employeeService:EmployeeService) 
  { 
  }
  ngOnInit(): void {
    this.employee=new Employee();
    this.id=this.route.snapshot.params['id'];
this.employeeService.getEmployee(this.id).subscribe(data=>{
  this.employee=data;
},
error=>console.log(error));
}
onSubmit()
{ 
  this.employeeService.updateEmployee(this.id,this.employee).subscribe(
    data => {            
      console.log(data);      
      this.gotoList();
},error=>{console.log(error);});
}
gotoList()
{
  this.router.navigate(['/employees']); 
}
}

update-employee.component.html

<!-- <p>update-employee works!</p> -->
<h3>Update Employee</h3>
<div style="width:400px">
    <form (ngSubmit)="onSubmit()">
        <div class="form-group">
            <label for="name">First Name:</label>
            <input type="text" class="form-control" id="firstName" required [(ngModel)]="employee.firstName" name="firstName">
        </div>
        <div class="form-group">
            <label for="name">Last Name:</label>
            <input type="text" class="form-control" id="lastName" required [(ngModel)]="employee.lastName" name="lastName">
        </div>
        <div class="form-group">
            <label for="name">Email id:</label>
            <input type="text" class="form-control" id="emailId" required [(ngModel)]="employee.emailId" name="emailId">
        </div>
        <button type="submit" class="btn btn-success">Submit</button>
    </form>
</div>

employee-details.component.ts

import { Component, OnInit } from '@angular/core';
import { ActivatedRoute, Router } from '@angular/router';
import { Employee } from '../employee';
import { EmployeeService } from '../employee.service';

@Component({
  selector: 'app-employee-details',
  templateUrl: './employee-details.component.html',
  styleUrls: ['./employee-details.component.css']
})
export class EmployeeDetailsComponent implements OnInit {
 id:number;
 employee:Employee;
  constructor(private route:ActivatedRoute,private router:Router,private empService:EmployeeService,) 
  { 
  }

  ngOnInit(): void {
    this.employee=new Employee();
    this.id=this.route.snapshot.params["id"];
    this.empService.getEmployee(this.id).subscribe(data=> {
      this.employee=data;
    },
    error=>{
      console.log(error);
    })
  }

}

employee-details.component.html

<!-- <p>employee-details works!</p> -->
<h2>Employee Details</h2>
<hr/>
<div *ngIf="employee">
</div>
<div>
<label><b>First Name:</b></label>
{{employee.firstName}}
</div>
<div>
    <label><b>Last Name:</b></label>
    {{employee.lastName}}
</div>
<div>
    <label><b>Email Id:</b></label>
    {{employee.emailId}}
</div>

create-employee.component.ts

import { ThrowStmt } from '@angular/compiler';
import { Component, OnInit } from '@angular/core';
import { Router } from '@angular/router';
import { Employee } from '../employee';
import { EmployeeService } from '../employee.service';

@Component({
  selector: 'app-create-employee',
  templateUrl: './create-employee.component.html',
  styleUrls: ['./create-employee.component.css']
})
export class CreateEmployeeComponent implements OnInit {
  employee:Employee=new Employee();
  submitted=false;
  constructor(private employeeService:EmployeeService,private router:Router) 
  { 

  }

  ngOnInit(): void {
  }
newEmployee():void{
  this.submitted=false;
  this.employee=new Employee();
}
onSubmit()
{
  this.submitted=true;
  this.save();
}
save()
{
  this.employeeService.createEmployee(this.employee).subscribe(
    data => {            
     // console.log(data);      
      this.gotoList();
},error=>{console.log(error);});
}
gotoList()
{
  this.router.navigate(['/employees']); 
}
}


create-employee.component.html

<!-- <p>update-employee works!</p> -->
<h3>Create Employee</h3>
<div  [hidden]="submitted" style="width:400px">
    <form (ngSubmit)="onSubmit()">
        <div class="form-group">
            <label for="name">First Name:</label>
            <input type="text" class="form-control" id="firstName" required [(ngModel)]="employee.firstName" name="firstName">
        </div>
        <div class="form-group">
            <label for="name">Last Name:</label>
            <input type="text" class="form-control" id="lastName" required [(ngModel)]="employee.lastName" name="lastName">
        </div>
        <div class="form-group">
            <label for="name">Email id:</label>
            <input type="text" class="form-control" id="emailId" required [(ngModel)]="employee.emailId" name="emailId">
        </div>
        <button type="submit" class="btn btn-success">Submit</button>
    </form>
</div>

<div [hidden]="!submitted">
    <h4>You submitted Successfully.</h4>
</div>

employee.json
{
  "employee": [
    {
      "id": 2,
      "firstName": "sai",
      "lastName": "ram",
      "emailId": "sairam@gmail.com",
      "active": true
    },
    {
      "firstName": "siva",
      "lastName": "rao",
      "emailId": "siva@gmail.com",
      "id": 3
    }
  ]
}







































	
	

	

		

















































 

















































